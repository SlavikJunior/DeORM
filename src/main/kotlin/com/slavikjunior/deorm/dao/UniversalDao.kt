package com.slavikjunior.deorm.dao

import com.slavikjunior.deorm.annotations.*
import com.slavikjunior.deorm.db_manager.DbConnectionManager
import com.slavikjunior.deorm.exceptions.DbAccessException
import com.slavikjunior.deorm.exceptions.NotNullableColumnException
import com.slavikjunior.deorm.dao.Dao
import com.slavikjunior.deorm.exceptions.NotAnnotatedTableException
import com.slavikjunior.deorm.orm.Entity
import com.slavikjunior.deorm.utils.isFieldAutogenerated
import com.slavikjunior.deorm.utils.isNullableColumn
import java.lang.reflect.Constructor
import java.math.BigDecimal
import java.sql.*

internal class UniversalDao<T : Entity>(
    private val typeParameterClass: Class<T>
) : Dao<T> {

    private var tableName: String? = getTableName()

    private val connection: Connection
        get() = DbConnectionManager.getConnection()

    @CreateMethod
    @Throws(DbAccessException::class, NotNullableColumnException::class)
    override fun createEntity(columnsToValues: Map<String, Any?>): Boolean {
        val columnsList = mutableListOf<String>()
        val valuesList = mutableListOf<Any?>()

        for (entry in columnsToValues.entries) {
            val column = entry.key
            val value: Any? = entry.value

            // Не вставляем автогенерируемое поле
            if (typeParameterClass.isFieldAutogenerated(column))
                continue

            columnsList.add(column)
            valuesList.add(value)
        }

        val columns = columnsList.toTypedArray()
        val values = valuesList.toTypedArray()

        var index = 0
        val sb = StringBuilder("insert into " + tableName + " (")
        for (column in columns) {
            sb.append(column)
            if (index++ < columnsList.size - 1) sb.append(", ")
        }
        sb.append(") values (")

        index = 0
        while (index++ < values.size - 1) {
            sb.append("?").append(", ")
        }
        sb.append("?").append(");")


        index = 1
        connection.use { connection ->
            connection.prepareStatement(sb.toString()).use { ps ->
                for (value in values) {
                    if (value == null) {
                        val isNullableColumn = typeParameterClass.isNullableColumn(
                            columns[index - 1]
                        )
                        if (isNullableColumn) ps.setNull(index++, Types.NULL)
                        else throw NotNullableColumnException("Column " + columns[index - 1] + " is not nullable")
                    } else if (value is String) ps.setString(index++, value)
                    else if (value is Int) ps.setInt(index++, value)
                    else ps.setObject(index++, value)
                }
                try {
                    return ps.executeUpdate() > 0
                } catch (e: SQLException) {
                    throw DbAccessException("Database access error occurs.", e)
                }
            }
        }
    }

    @ReadMethod
    @Throws(SQLException::class)
    override fun readEntityByValues(columnsToValues: Map<String, Any?>): List<T>? {
        var index = 0
        val sb = StringBuilder("select * from " + tableName + " where ")
        for (entry in columnsToValues.entries) {
            val columnName = entry.key
            val value = entry.value
            sb.append(columnName)
            if (value == null)
                sb.append(" is null")
            else
                sb.append(" = ?")
            if (index < columnsToValues.size - 1) sb.append(" and ")
            index++
        }
        sb.append(';')

        var result: List<T>? = null
        connection.prepareStatement(sb.toString()).use { ps ->
            val values = columnsToValues.values.stream().filter { it != null }.toArray()
            index = 1
            for (value in values) {
                when (value) {
                    is String -> ps.setString(index++, value)
                    is Int -> ps.setInt(index++, value)
                    else -> ps.setObject(index++, value)
                }
            }
            ps.executeQuery().use { rs -> result = createInstanceByResultSet(rs) }
        }
        return result
    }

    @UpdateMethod
    @Throws(SQLException::class)
    override fun updateEntityByValues(id: Int, columnsToValues: Map<String, Any?>): Boolean {
        var index = 0
        val sb = StringBuilder("update " + tableName + " set ")
        for (entry in columnsToValues.entries) {
            val columnName = entry.key
            sb.append(columnName).append(" = ?")
            if (index < columnsToValues.size - 1)
                sb.append(", ")
            index++
        }
        sb.append(" where id = ?;")

        var count = 0
        connection.prepareStatement(sb.toString()).use { ps ->
            val values = columnsToValues.values.stream()
            index = 1
            for (value in values) {
                when (value) {
                    is String -> ps.setString(index++, value)
                    is Int -> ps.setInt(index++, value)
                    null -> ps.setNull(index++, Types.NULL)
                    else -> ps.setObject(index++, value)
                }
            }
            // "where id = ? -> where id = $id"
            ps.setInt(index++, id)
            count = ps.use { ps ->
                ps.executeUpdate()
            }
            return count > 0
        }
    }

    @DeleteMethod
    @Throws(DbAccessException::class)
    override fun deleteEntityByValues(columnsToValues: Map<String, Any?>): Boolean {
        var index = 0
        val sb = StringBuilder("delete from " + tableName + " where ")
        for (entry in columnsToValues.entries) {
            val columnName = entry.key
            val value = entry.value

            sb.append(columnName)
            if (value != null)
                sb.append(" = ?")
            else
                sb.append(" is null")
            if (index++ < columnsToValues.size - 1) sb.append(" and ")
        }
        sb.append(';')

        val ps: PreparedStatement
        val values = columnsToValues.values.stream().filter { it != null }.toArray()
        var cntOfChangedRows = 0
        connection.use { connection ->
            ps = connection.prepareStatement(sb.toString())
            index = 1
            for (value in values) {
                when (value) {
                    is String -> ps.setString(index++, value)
                    is Int -> ps.setInt(index++, value)
                    null -> ps.setNull(index++, Types.NULL)
                    else -> ps.setObject(index++, value)
                }
            }
            ps.use { ps ->
                cntOfChangedRows = ps.executeUpdate()
            }
        }
        return cntOfChangedRows > 0
    }

    private fun createInstanceByResultSet(rs: ResultSet): List<T> {
        val rsmd = rs.metaData
        val columnCount = rsmd.columnCount

        val result = mutableListOf<T>()
        // todo добавить поддержку возврата множества объектов
        while (rs.next()) {
            val initArgs = mutableListOf<Any?>()
            for (i in 1..columnCount) {
                val type = rsmd.getColumnClassName(i)
                val label = rsmd.getColumnLabel(i)

                // todo добавить обработку типов
                initArgs += when (type) {
                    String::class.java.name -> rs.getString(label)
                    Integer::class.java.name -> rs.getInt(label)
                    Timestamp::class.java.name -> rs.getTimestamp(label)
                    Boolean::class.java.name -> rs.getBoolean(label)
                    BigDecimal::class.java.name -> rs.getBigDecimal(label)
                    Object::class.java.name -> rs.getObject(label)
                    else -> {}
                }
            }
            result.add(getConstructor(initArgs)?.newInstance(*initArgs.toTypedArray()) as T)
        }
        return result.ifEmpty { mutableListOf() }
    }

    @Throws(NotAnnotatedTableException::class)
    private fun getTableName(): String {
        if (tableName == null) {
            tableName = typeParameterClass.getAnnotation(Table::class.java)?.name
                ?: throw NotAnnotatedTableException("Table annotation not found on ${typeParameterClass.simpleName}.")
        }
        return tableName!!
    }

    override fun getLastId(entityClass: Class<T>): Int? {
        val sql = "select max(id) from $tableName;"
        connection.prepareStatement(sql).use { ps ->
            ps.executeQuery().use { rs -> return rs.getInt(1) }
        }
    }

    // todo подразумевается, что в классе есть однозначная корреляция колчества аргументов с конструктором занести в документацию
    private fun getConstructor(initArgs: List<Any?>) =
        typeParameterClass.declaredConstructors
            .map { it -> it.isAccessible = true; it }
            .find { it.parameterCount == initArgs.size }
}